=== Комуникационни протоколи

Git може да използва 4 основни протокола за трансфер на данни: локален, HTTP, Secure Shell (SSH) и Git.
Сега ще погледнем какво представляват те и по какви причини бихте желали да ги използвате (или избягвате).

==== Локален протокол

(((protocols, local)))
Най-простият от четирите е _локалният протокол_, при който отдалеченото хранилище се намира просто в друга директория на диска.
Това често се ползва, ако всички в екипа ви имат достъп до споделена файлова система от рода на https://en.wikipedia.org/wiki/Network_File_System[NFS^] споделено устройство или пък, в по-редки случаи, когато всички се логват на един и същи компютър.
Последното не е препоръчително, защото всички копия на хранилището ще се пазят на едно място и рискът от загубата на данни при хардуерна повреда е значително по-голям.

Ако имате споделена монтирана файлова система, тогава вие клонирате, изпращате и изтегляте данни от локално, файлово-базирано хранилище.
За да клонирате хранилище от този вид или за да добавите такова като отдалечено към съществуващ проект, използвайте пътя до хранилището вместо URL.
Например, за да клонирате, може да изпълните нещо подобно:

[source,console]
----
$ git clone /srv/git/project.git
----

Или пък така:

[source,console]
----
$ git clone file:///srv/git/project.git
----

Git работи малко по-различно ако изрично укажете `file://` като префикс на пътя.
Ако укажете само пътя, системата се опитва да използва hardlinks или директно копира файловете, които са нужни.
Ако укажете `file://`, Git ще стартира процеси, които нормално се използват за мрежов трансфер, което е една идея по-малко ефективен метод за трансфер на данни.
Главната причина да използвате префикса `file://` е, че можете да искате чисто копие на хранилището, без неприсъщи референции или обекти в него - основно при импорт от други VCS системи или нещо подобно (вижте <<ch10-git-internals#ch10-git-internals>> за повече подробности).
Тук ние ще използваме нормални пътища, защото това почти винаги работи по-бързо.

За да добавите локално хранилище като remote към съществуващ Git проект, можете да направите това:

[source,console]
----
$ git remote add local_proj /srv/git/project.git
----

След това, можете да изпращате и издърпвате от него използвайки името му `local_proj` по същия начин, по който ако то беше в мрежа.

===== Предимствата

Предимствата на файл-базираните хранилища са в това, че са прости и използват наличните права за файловете и мрежовия достъп.
Ако вече имате споделена файлова система, до която има достъп целия ви екип, създаването на хранилище е много просто.
Пазите копие от bare хранилището някъде, където всички имат достъп и задавате права за чете и писане като на всяка друга споделена директория.
Ще дискутираме как да експортирате копие от хранилището като bare копие за целта в <<ch04-git-on-the-server#_getting_git_on_a_server>>.

Това също е полезен начин за бързо изтегляне на работата на друг човек от неговото работещо хранилище.
Ако с ваш колега работите по един и същи проект и той поиска да погледнете нещо по неговата работа, то една команда от рода на `git pull /home/john/project` вероятно ще е по-лесна опция от това той да изпрати нещо до мрежовото хранилище и вие след това да го теглите при вас.

===== Недостатъци

Неудобствата при този подход се състоят в това, че споделеният достъп в повечето случаи се настройва и достъпва от различни локации по-трудно в сравнение със стандартния мрежов достъп.
Ако искате да изпратите данни от домашния си лаптоп, докато сте вкъщи, ще трябва да монтирате отдалечения диск, което често може да е трудно и досадно бавно.

Също така трябва да посочим, че локалният протокол не винаги е най-бързата опция, ако използвате споделен монтиран ресурс от някои видове.
Локалното хранилище е бързо само, ако имате бърз достъп до данните.
Едно хранилище разположено върху NFS ресурс често е по-бавно от SSH такова на същия сървър (което освен това позволява на Git да работи през локалните дискове на всеки от компютрите).

Накрая, този протокол не защитава хранилището от непредвидени поражения.
Всеки потребител разполага с пълен шел достъп до "`отдалеченото`" хранилище и нищо не пречи на един невнимателен колега да промени или изтрие служебни Git файлове, което от своя страна да повреди цялото хранилище.

==== HTTP протоколите

Git може да работи през HTTP в два различни режима.
Преди Git версия 1.6.6, начинът беше само един и то доста опростен и в общия случай - read-only.
С тази версия обаче, беше представен нов, по-усъвършенстван протокол, който позволява на Git интелигентно да уговаря транфера на данни по маниер подобен на този, който се използва през SSH.
В последните няколко години този нов HTTP протокол придоби голяма популярност, защото е по-прост за потребителя и по-интелигентен в механизма на комуникация.
Тази нова версия често е наричана _Smart_ HTTP протокол, докато старата е известна като _Dumb_ HTTP.
Ще разгледаме първо smart HTTP протокола.

===== Smart HTTP

(((protocols, smart HTTP)))
Протоколът smart HTTP работи много подобно на SSH или Git протоколите, но използва стандартните HTTP/S портове и може да използва различни механизми за HTTP автентикация, което често го прави по-лесен за много потребители, защото можете да използвате неща като оторизиране с име и парола, вместо създаване на SSH ключове.

Този протокол в момента е най-популярния начин за използване в Git, понеже може да работи както анонимно, подобно на протокола `git://`, така и с криптиране подобно на SSH и автентикация.
Вместо да създавате различни URLи за тези неща, сега можете да използвате единичен URL за всички тях.
Ако се опитате да изпратите данни към хранилище настроено да изисква оторизация (както би следвало да е), сървърът може да ви попита за потребителско име и парола за достъп.
Същото важи и за достъпа само за четене.

На практика, в услуги като GitHub, URL-ът който ползвате за да разглеждате хранилището в браузъра (например, https://github.com/schacon/simplegit[^]) е същият URL, който можете да използвате за клонирането му или пък за изпращане на промени към него (ако имате права за това).

===== Dumb HTTP

(((protocols, dumb HTTP)))
Ако сървърът не разполага с Git HTTP smart услуга, Git клиентът ще се опита да използва протокола _dumb_ HTTP.
Този вид комуникация очаква bare Git хранилището да се обслужва като нормални файлове от уеб сървъра.
Красотата на dumb протокола се крие в простотата на настройката му.
В общи линии, всичко което трябва да направите е да копирате едно bare Git хранилище там където уеб сървърът има достъп и да настроите специфичен `post-update` hook, след което сте готови (вижте <<ch08-customizing-git#_git_hooks>>).
Сега всички, които имат достъп до уеб сървъра, ще могат да клонират хранилището ви.
За да позволите достъп за четене до хранилището през HTTP, направете нещо такова:

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

Това е всичко.(((hooks, post-update)))
Инструментът `post-update`, който идва с Git, по подразбиране изпълнява съответната команда (`git update-server-info`) така че HTTP издърпването и клонирането да работят коректно.
Тази команда се изпълнява, когато изпращате към това хранилище, вероятно през SSH, след което други потребители могат да клонират посредством нещо такова:

[source,console]
----
$ git clone https://example.com/gitproject.git
----

В този специфичен случай, ние използваме `/var/www/htdocs` пътя, който е стандартен за Apache инсталациите, но вие можете да ползвате който и да е статичен уеб сървър -- просто сложете bare хранилището в неговия път.
Git данните се обслужват като базови статични файлове (вижте <<ch10-git-internals#ch10-git-internals>> за повече информация как точно става това).

Kато обобщение, имате два избора, да пуснете read/write Smart HTTP сървър или read-only такъв с Dumb HTTP.
Рядко се случва да се прави комбинация от двете.

===== Предимствата

Ще разгледаме предимствата на Smart HTTP версията на протокола.

Простотата да имате единичен URL за всички видове достъп и да оставите сървърът да пита за име и парола, когато се налага, прави нещата много по-лесни за крайния потребител.
Възможността за оторизация с име и парола е голямо предимство сравнена с SSH, защото потребителите няма нужда да генерират SSH ключове локално и да изпращат публичния си ключ към сървъра преди да могат да комуникират с него.
За по-неопитните потребители или за потребителите на системи, в които SSH не се ползва интензивно, това може да бъде голямо улеснение по отношение на лекотата на ползване.
В допълнение, протоколът е бърз и ефективен, подобно на SSH.

Можете също да обслужвате хранилищата си само за четене през HTTPS, което значи че можете да криптирате съдържанието на трансфера или дори да стигнете и до по-рестриктивни мерки, като например да изисквате от клиентите да използват специфични signed SSL сертификати.

Друго предимство е и факта, че HTTP и HTTPS са толкова разпространени протоколи, че корпоративните защитни стени често вече са настроени да пропускат трафика през техните портове.

===== Недостатъци

Git през HTTP/S може да е една идея по-сложен за настройване в сравнение с SSH на някои сървъри.
Отделно от това, съществува съвсем леко предимство, което другите протоколи за обслужване на Git имат, в сравнение със Smart HTTP.

Ако използвате HTTP за автентикирано изпращане на промени към хранилището, изпращането на името и паролата понякога може да е малко по-сложно отколкото използването на SSH ключове.
Обаче, съществуват няколко credential caching инструменти, които можете да ползвате, включително Keychain access на OSX или Credential Manager под Windows, за да си улесните нещата.
Погледнете <<ch07-git-tools#_credential_caching>> за да видите как да настроите системата за защитено кеширане на HTTP пароли.

==== SSH протоколът

(((protocols, SSH)))
Често използван протокол за Git при self-hosting инсталации е SSH.
Това е защото SSH достъпът до сървърите е много разпространен и настроен на повечето от тях - а и да не е, лесно може да се пусне.
SSH също така е автентикиран мрежов протокол, повсеместно използван и лесно управляем.

За да клонирате Git хранилище през SSH, използвайте `ssh://` URL като този:

[source,console]
----
$ git clone ssh://[user@]server/project.git
----

Или, може да предпочетете съкратения, подобен на scp синтаксис:

[source,console]
----
$ git clone [user@]server:project.git
----

И в двата случая отгоре, ако не укажете потребителско име, Git ще използва това, с което сте логнати в системата.

===== Предимствата

Предимствата на SSH са много.
Първо, SSH е сравнително лесен за настройка - SSH демоните са често използвани и познати, повечето системни администратори имат опит с тях и повечето OS дистрибуции идват с настроен SSH или имат съответните средства за настройка и управление на SSH комуникация.
След това, комуникацията е сигурна - целият трансфер през SSH е криптиран и оторизиран.
Последно, подобно на HTTP/S, Git и Local протоколите, SSH е ефективен и прави данните максимално компактни преди да ги изпрати.

===== Недостатъци

Негативната страна на SSH е, че не можете да имате анонимен достъп.
Потребителите трябва да имат достъп до машината ви през SSH, за да се доберат до хранилището ви, дори и в режим само за четене, което не прави SSH толкова подходящ за проекти с отворен код.
Ако го използвате само в рамките на корпоративната мрежа, SSH може да е единственият протокол, с който се налага да работите.
Ако искате да позволите анонимен достъп само за четене до вашите проекти и същевременно искате да ползвате SSH, ще трябва да настроите SSH за вас, за да изпращате до хранилището, но за колегите, които ще теглят - ще трябва да настроите друг метод.

==== Git протокол

(((protocols, git)))
Следва протоколът Git.
Той е реализиран чрез специален daemon, който идва заедно с Git, слуша на специфичен порт (9418) и осигурява услуга подобна на тази на SSH, но без абсолютно никаква автентикация.
Ако искате хранилището ви да е достъпно през този протокол, трябва да създадете файл `git-daemon-export-ok`, иначе daemon-ът няма да го обслужва. Това е единственият вид защита при този протокол.
Такова Git хранилище няма опции - или е достъпно за клониране от всички или не е.
Това означава, че по подразбиране при този протокол не можете да изпращате данни към хранилището (pushing).
Можете да го разрешите, но предвид тоталната липса на автентикация, това не е добра идея - всеки в Интернет, който се сдобие с URLа на хранилището ви, ще може да го променя.
Достатъчно е да се каже, че това е рядкост.

===== Предимства

Git протоколът често е най-бързия мрежов протокол.
Ако обслужвате голям трафик за публичен проект, или пък проектът е много голям и не изисква автентикация за четене, вероятно ще си заслужава да пуснете Git daemon.
Той използва същия механизъм за трансфер на данни като SSH, но без забавянето за криптиране и автентикация.

===== Недостатъци

Недостатъкът на Git протокола е липсата на автентикация.
Като цяло е нежелателно Git протоколът да е единствения протокол за достъп до вашия проект.
В повечето случаи, може да го ползвате в комбинация с SSH или HTTPS за достъп от ваши сътрудници, които трябва да имат права за запис в хранилището, а всички останали - read-only достъп през `git://`.
Освен това, Git вероятно е най-трудния за настройка протокол.
Той трябва да пусне свой собствен daemon, което може да изисква `xinetd`/`systemd` конфигурация или нещо подобно, а това не е сред най-приятните неща за един системен администратор.
Също така, протоколът изисква защитната стена да пропуска трафик през порт 9418, което не е стандартна опция за корпоративните такива и обикновено се блокира.
